# Card Games (Solitaire & Black Jack) - Copilot Instructions

**Focus Area:** Interactive card games, game state management, session persistence, external API integration.

**Key Files:**
- Game Logic: `GameLogic/SolitaireGameState.cs` (249 lines - core solitaire implementation)
- Services: `Infrastructure/Services/CardService.cs`
- Pages: `Pages/Games/Solitaire.razor`, `Pages/Games/BlackJack.razor`, `Pages/Games/CardGames.razor`
- Components: `Components/SolitaireBoard.razor`, `Components/BlackJackBoard.razor`, `Components/CardGames.razor`
- Models: `Models/Card.cs`, `Models/CardDraw.cs`, `Models/NewDeck.cs`
- Constants: `Constants/Game/SolitaireImages.cs`, `Constants/Game/BlackJack.cs`, `Constants/Game/General.cs`
- Data: `Data/jsnoverdotnetdbContext.cs` (Card-related entities)

## Games Architecture Overview

The game system follows a **state machine pattern** for robust game management:

```
Razor Component (UI)
    ↓ calls
CardService (Session Management)
    ↓ stores/retrieves
Blazored.SessionStorage (Browser Local Storage)
    ↓ persists
Browser SessionStorage (in-memory across page reloads)

SolitaireGameState (Game Logic)
    ↓ manipulates
Card Model (State Data)
    ↓ validates
CardComparer Utility (Rules Validation)
```

## Two Games Implemented

### 1. Solitaire (Klondike)

**Game Logic:** `GameLogic/SolitaireGameState.cs` (249 lines)

**State Structure:**
```csharp
public class SolitaireGameState {
    public List<Card> Stock { get; set; }        // Draw pile (face down)
    public List<Card> Waste { get; set; }        // Discard from stock (face up)
    public List<Card>[] Tableau { get; set; }    // 7 columns for play
    public List<Card>[] Foundations { get; set; } // 4 stacks for Ace-to-King
    public int MoveCount { get; set; }
    public DateTime StartTime { get; set; }
    public bool IsWon { get; set; }
}
```

**Core Operations:**
- **Draw from Stock:** Move card from Stock to Waste (3-card or 1-card draw mode)
- **Move Tableau to Tableau:** Drag column of cards to another tableau if valid (descending rank, alternating color)
- **Move Tableau to Foundation:** Auto-move card if it's the next rank in suit
- **Move Foundation back to Tableau:** Undo invalid moves
- **Detect Win:** All cards in foundations = game won

**State Validation:**
- No moving face-down cards
- Tableau columns must have valid rank sequences (K→Q→J→10→...→A)
- Foundation stacks must go Ace→King in same suit
- Waste cards can only go to Tableau or Foundation

### 2. Black Jack

**Game Type:** Simplified dealer vs. player variant

**Rules:**
- Player starts with 2 cards
- Dealer starts with 1 face-up, 1 face-down
- Player can Hit (draw), Stand, or Bust (>21)
- Dealer must hit on 17 or below
- Winner: Closest to 21 without busting
- Blackjack: Ace + 10-value = 21 with 2 cards = auto-win

**Implementation:** Likely in `Pages/Games/BlackJack.razor` or `Components/BlackJackBoard.razor`

**Current Status:** Game logic may be partially in component code-behind; consider refactoring to dedicated service

## CardService (Session Management)

**Location:** `Infrastructure/Services/CardService.cs`

### Key Responsibilities

1. **Deck Initialization:** Call external `deckofcardsapi.com` to get shuffled card data
2. **Session Storage:** Persist game state in `Blazored.SessionStorage`
3. **Game State Management:** Load/save game state across page reloads
4. **Card Data Model:** Map API response to `Card` model

### CardService Methods

```csharp
// Initialize deck
Task<NewDeck> InitializeDeckAsync();

// Solitaire-specific
Task<SolitaireGameState> InitializeSolitaireAsync();
Task SaveSolitaireGameAsync(SolitaireGameState state);
Task<SolitaireGameState> LoadSolitaireGameAsync();

// Black Jack-specific
Task<BlackJackGameState> InitializeBlackJackAsync();
Task SaveBlackJackGameAsync(BlackJackGameState state);
Task<BlackJackGameState> LoadBlackJackGameAsync();

// Generic session operations
Task SetSessionAsync(string key, object value);
Task<T> GetSessionAsync<T>(string key);
Task ClearSessionAsync(string key);
```

### External API Integration (deckofcardsapi.com)

**Free API Endpoint:** `https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1`

**Response Model:**
```json
{
    "success": true,
    "deck_id": "3p40pgl6x0so",
    "shuffled": true,
    "remaining": 52
}
```

**Card Drawing:**
```csharp
// After getting deck_id, draw cards
GET https://deckofcardsapi.com/api/deck/{deck_id}/draw/?count=5

// Response:
{
    "success": true,
    "cards": [
        {"code": "AS", "image": "...", "value": "ACE", "suit": "SPADES"},
        // ...
    ],
    "deck_id": "3p40pgl6x0so",
    "remaining": 47
}
```

**Implementation Pattern:**
```csharp
using (var httpClient = new HttpClient()) {
    var deckResponse = await httpClient.GetAsync(
        "https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1"
    );
    var deckJson = await deckResponse.Content.ReadAsStringAsync();
    var deck = JsonSerializer.Deserialize<NewDeck>(deckJson);
    
    // Now draw cards
    var cardsResponse = await httpClient.GetAsync(
        $"https://deckofcardsapi.com/api/deck/{deck.DeckId}/draw/?count=5"
    );
    // ... process response
}
```

### Known Issues & Resilience

**Anti-Pattern ⚠️:** No retry logic or error handling for API failures
- If `deckofcardsapi.com` is down, game initialization fails
- No circuit breaker; repeated failures spike API calls

**Improvement Opportunities:**

1. **Fallback Deck:** Generate local deck if API fails
   ```csharp
   private List<Card> GenerateLocalDeck() {
       var suits = new[] { "SPADES", "HEARTS", "DIAMONDS", "CLUBS" };
       var values = new[] { "ACE", "2", "3", // ... "KING" };
       // Generate all 52 cards locally
   }
   ```

2. **Retry Policy (Polly):** Add NuGet `Polly` and implement retries
   ```csharp
   var retryPolicy = Policy<HttpResponseMessage>
       .Handle<HttpRequestException>()
       .Or<TaskCanceledException>()
       .OrResult(r => !r.IsSuccessStatusCode)
       .WaitAndRetryAsync(retryCount: 3, sleepDurationProvider: ...);
   
   var response = await retryPolicy.ExecuteAsync(() => httpClient.GetAsync(...));
   ```

3. **Caching:** Cache deck initialization for same session
   ```csharp
   private static readonly Dictionary<string, NewDeck> _deckCache = new();
   ```

## Session Storage Integration (Blazored.SessionStorage)

**NuGet Package:** `Blazored.SessionStorage` v2.2.0

### Pattern

```csharp
@inject Blazored.SessionStorage.ISessionStorageService sessionStorage

@code {
    private SolitaireGameState currentGame;
    
    protected override async Task OnInitializedAsync() {
        // Load game from session
        currentGame = await sessionStorage.GetItemAsync<SolitaireGameState>("solitaire_game");
        
        if (currentGame == null) {
            // New game
            currentGame = await cardService.InitializeSolitaireAsync();
        }
    }
    
    private async Task SaveGameAsync() {
        // Persist to session
        await sessionStorage.SetItemAsync("solitaire_game", currentGame);
    }
    
    private async Task ClearGameAsync() {
        // Delete from session
        await sessionStorage.RemoveItemAsync("solitaire_game");
    }
}
```

### Key Features

- **Local Storage:** Data persists across browser tabs in same domain
- **Session-Scoped:** Data cleared when browser closed (unlike `localStorage`)
- **No Size Limits (practical):** Supports game state objects (~100KB for 52 cards)
- **Async API:** All operations are asynchronous

### Gotchas & Best Practices

1. **Key Naming:** Use consistent string keys across components
   ```csharp
   private const string SOLITAIRE_GAME_KEY = "game_solitaire";
   private const string BLACKJACK_GAME_KEY = "game_blackjack";
   ```

2. **Null Checks:** `GetItemAsync<T>()` returns `null` if key doesn't exist
   ```csharp
   var game = await sessionStorage.GetItemAsync<SolitaireGameState>(key);
   if (game == null) {
       // Initialize new game
   }
   ```

3. **Serialization:** Objects must be JSON-serializable; avoid circular references
   ```csharp
   // ✅ Good: Clean model with [Serializable] or JsonPropertyName
   public class GameState {
       [JsonPropertyName("game_id")]
       public string GameId { get; set; }
   }
   
   // ❌ Bad: Circular references break serialization
   public class Card {
       public GameState Game { get; set; }  // Avoid back-references
   }
   ```

4. **Performance:** SessionStorage is synchronous on main thread; large objects (>1MB) may cause lag
   ```csharp
   // Consider pagination if storing large game histories
   var recentGames = games.OrderByDescending(g => g.PlayDate).Take(5).ToList();
   ```

## Card Models

### Card.cs

```csharp
public class Card {
    public int CardId { get; set; }
    public string Suit { get; set; }         // SPADES, HEARTS, DIAMONDS, CLUBS
    public string Rank { get; set; }         // ACE, 2-10, JACK, QUEEN, KING
    public string Value { get; set; }        // Numeric value for Black Jack
    public string Code { get; set; }         // 2-letter code: AS (Ace of Spades)
    public string ImageUrl { get; set; }     // URL from deckofcardsapi.com
}
```

### CardDraw.cs

```csharp
public class CardDraw {
    public int DrawId { get; set; }
    public string DeckId { get; set; }
    public List<Card> DrawnCards { get; set; }  // Cards returned from API
    public int Remaining { get; set; }          // Cards left in deck
    public DateTime DrawnAt { get; set; }
}
```

### NewDeck.cs

```csharp
public class NewDeck {
    public bool Success { get; set; }
    public string DeckId { get; set; }
    public bool Shuffled { get; set; }
    public int Remaining { get; set; }
}
```

## Game State Persistence

### Solitaire Game Save/Load Example

```csharp
// Save to session
public async Task SaveGameAsync(SolitaireGameState game) {
    await sessionStorage.SetItemAsync("solitaire_game", new {
        game.Stock,        // List<Card>
        game.Waste,        // List<Card>
        game.Tableau,      // List<Card>[]
        game.Foundations,  // List<Card>[]
        game.MoveCount,
        game.StartTime,
        game.IsWon
    });
}

// Load from session
public async Task<SolitaireGameState> LoadGameAsync() {
    var saved = await sessionStorage.GetItemAsync<SolitaireGameState>("solitaire_game");
    return saved;
}
```

### Data Size Estimate

- 52 cards × ~500 bytes per card (code, suit, rank, image URL) = ~26KB
- Acceptable for sessionStorage (typical limit: 5-10MB)

## Game Components (UI)

### SolitaireBoard.razor

**Responsibilities:**
- Display stock, waste, tableau, and foundation areas
- Handle drag-and-drop for card movement
- Track valid moves using `CardComparer`
- Update game state in `SolitaireGameState`
- Persist to session storage

**Component Pattern:**
```razor
@page "/Solitaire"
@inject CardService cardService
@inject Blazored.SessionStorage.ISessionStorageService sessionStorage
@inject NavigationManager navManager

<div class="solitaire-board">
    <div class="stock-waste">
        <!-- Stock pile and Waste pile rendering -->
    </div>
    <div class="foundations">
        <!-- 4 foundation stacks -->
    </div>
    <div class="tableau">
        <!-- 7 tableau columns with @ondrop, @ondragstart handlers -->
    </div>
</div>

@code {
    private SolitaireGameState gameState;
    
    protected override async Task OnInitializedAsync() {
        gameState = await cardService.LoadSolitaireGameAsync();
        if (gameState == null) {
            gameState = await cardService.InitializeSolitaireAsync();
        }
    }
    
    private async Task OnCardDroppedAsync(Card card, string targetPile) {
        // Validate move using CardComparer
        if (CardComparer.IsValidMove(card, targetPile)) {
            // Update game state
            gameState.MoveCard(card, targetPile);
            gameState.MoveCount++;
            
            // Check for win
            if (gameState.AllCardsInFoundations()) {
                gameState.IsWon = true;
            }
            
            // Save to session
            await cardService.SaveSolitaireGameAsync(gameState);
        }
    }
    
    private async Task ResetGameAsync() {
        gameState = await cardService.InitializeSolitaireAsync();
        await cardService.SaveSolitaireGameAsync(gameState);
    }
}
```

### CardGames.razor

**Responsibilities:**
- Game selection UI
- Links to Solitaire and Black Jack pages
- Start new game initialization

```razor
@page "/CardGames"

<div class="game-selection">
    <h1>Choose a Game</h1>
    <ul>
        <li>
            <a href="/Solitaire">
                <img src="/images/solitaire.png" alt="Solitaire" />
                <h2>Solitaire (Klondike)</h2>
                <p>Classic patience card game</p>
            </a>
        </li>
        <li>
            <a href="/BlackJack">
                <img src="/images/blackjack.png" alt="Black Jack" />
                <h2>Black Jack</h2>
                <p>Dealer vs. player card game</p>
            </a>
        </li>
    </ul>
</div>
```

## CardComparer Utility

**Location:** `Infrastructure/Utilities/CardComparer.cs`

**Purpose:** Validate moves according to game rules without affecting game state

```csharp
public static class CardComparer {
    // Solitaire validation
    public static bool IsValidTableauMove(Card source, List<Card> targetColumn) {
        // Must be descending rank (K→Q→J→...)
        // Must be alternating color (Red→Black→Red)
        var targetTop = targetColumn.LastOrDefault();
        if (targetTop == null) return source.Rank == "KING";  // Empty column needs King
        
        return IsDescendingRank(source.Rank, targetTop.Rank)
            && IsAlternatingColor(source.Suit, targetTop.Suit);
    }
    
    public static bool IsValidFoundationMove(Card source, List<Card> foundationStack) {
        // Must match suit
        // Must be ascending rank (A→2→3→...→K)
        var foundationTop = foundationStack.LastOrDefault();
        
        if (foundationTop == null) {
            return source.Rank == "ACE";  // New foundation must start with Ace
        }
        
        return source.Suit == foundationTop.Suit
            && IsAscendingRank(source.Rank, foundationTop.Rank);
    }
    
    // Black Jack validation
    public static int GetBlackJackValue(Card card) {
        return card.Rank switch {
            "ACE" => 11,  // or 1 in soft hand
            "JACK" or "QUEEN" or "KING" => 10,
            _ => int.Parse(card.Rank)
        };
    }
    
    public static bool IsBlackJack(List<Card> hand) {
        return hand.Count == 2
            && GetBlackJackValue(hand) == 21;
    }
}
```

## Common Game Tasks

### Implementing a New Game

1. **Create Game State Class:** (e.g., `PokerGameState.cs` in `GameLogic/`)
2. **Add Service Methods:** Extend `CardService` with initialization/load/save
3. **Create Page/Component:** Add `.razor` files for UI
4. **Implement Validation:** Add rules to `CardComparer.cs` or new utility
5. **Add Tests:** Create `PokerGameStateTests.cs` in `UnitTests/`
6. **Add Constants:** Create `Constants/Game/Poker.cs` for config

### Resetting a Game

```csharp
private async Task ResetGameAsync() {
    await sessionStorage.RemoveItemAsync("solitaire_game");
    gameState = await cardService.InitializeSolitaireAsync();
    await cardService.SaveSolitaireGameAsync(gameState);
}
```

### Determining Win Condition

```csharp
public bool CheckWinCondition(SolitaireGameState game) {
    // Solitaire: All 52 cards in foundations
    var cardsInFoundations = game.Foundations.Sum(f => f.Count);
    return cardsInFoundations == 52;
}

public bool CheckWinCondition(BlackJackGameState game) {
    // Black Jack: Player closer to 21 than dealer without busting
    var playerTotal = CalculateTotal(game.PlayerHand);
    var dealerTotal = CalculateTotal(game.DealerHand);
    
    return playerTotal <= 21 && playerTotal > dealerTotal || dealerTotal > 21;
}
```

## Testing Game Logic

**Location:** `UnitTests/SolitaireGameStateTests.cs` (currently empty)

### Example Unit Tests

```csharp
public class SolitaireGameStateTests {
    private SolitaireGameState _gameState;
    
    [Fact]
    public void InitializeGame_Creates52Cards() {
        var game = new SolitaireGameState();
        game.Initialize();
        
        var totalCards = game.Stock.Count + game.Waste.Count
            + game.Tableau.Sum(t => t.Count)
            + game.Foundations.Sum(f => f.Count);
        
        Assert.Equal(52, totalCards);
    }
    
    [Fact]
    public void DrawFromStock_MovesCardToWaste() {
        var initialStock = _gameState.Stock.Count;
        
        _gameState.DrawFromStock();
        
        Assert.Equal(initialStock - 1, _gameState.Stock.Count);
        Assert.Single(_gameState.Waste);
    }
    
    [Fact]
    public void IsValidTableauMove_KingToEmptyColumn_ReturnsTrue() {
        var king = _gameState.Waste.First(c => c.Rank == "KING");
        var emptyColumn = new List<Card>();
        
        var isValid = CardComparer.IsValidTableauMove(king, emptyColumn);
        
        Assert.True(isValid);
    }
    
    [Fact]
    public void IsValidTableauMove_NonKingToEmptyColumn_ReturnsFalse() {
        var queen = _gameState.Waste.First(c => c.Rank == "QUEEN");
        var emptyColumn = new List<Card>();
        
        var isValid = CardComparer.IsValidTableauMove(queen, emptyColumn);
        
        Assert.False(isValid);
    }
    
    [Fact]
    public void CheckWinCondition_AllCardsInFoundations_ReturnsTrue() {
        // Move all 52 cards to foundations (setup)
        // ...
        
        var isWon = _gameState.CheckWinCondition();
        
        Assert.True(isWon);
    }
}
```

### Current Testing Gaps

| Gap | Solution |
|-----|----------|
| **No SolitaireGameState tests** | Implement `SolitaireGameStateTests.cs` |
| **No CardComparer tests** | Add unit tests for move validation |
| **No CardService tests** | Mock HttpClient, test API integration and session storage |
| **No Black Jack logic tests** | Implement `BlackJackGameStateTests.cs` |
| **No component tests** | Consider Blaz
or component testing library (bunit) |

## Performance & Optimization

### Current Performance

- **Deck Initialization:** ~100-200ms (network call to `deckofcardsapi.com`)
- **Game State Serialization:** ~5-10ms (52 cards → JSON)
- **Session Storage Write:** ~2-5ms (browser I/O)

### Optimization Opportunities

1. **Parallel Card Draining:** Draw multiple cards at once instead of one per request
   ```csharp
   // Instead of: await cardService.DrawCard()
   // Use: await cardService.DrawCardsAsync(count: 10)
   ```

2. **Local Deck Generation Fallback:** Avoid API dependency entirely
   ```csharp
   // If deckofcardsapi.com unavailable, generate locally
   ```

3. **Game State Compression:** Store only delta changes instead of full state
   ```csharp
   // Instead of: Each save = full 52-card state
   // Use: Save only moves made, reconstruct state on load
   ```

4. **Image Caching:** Card images from API; consider pre-caching
   ```html
   <!-- Preload card images -->
   <link rel="prefetch" href="..." />
   ```

## Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| **Game state lost on page refresh** | SessionStorage key mismatch | Verify key consistency between save/load |
| **API timeout initializing deck** | deckofcardsapi.com slow or down | Implement timeout, fallback to local deck |
| **Cards not dragging/dropping** | Missing `@ondrop`, `@ondragstart` handlers | Add event handlers to card elements |
| **Game doesn't detect win** | Win condition logic incorrect | Test `CheckWinCondition()` method |
| **Session storage full** | Too many game states stored | Clear old games: `RemoveItemAsync()` |
| **Card images not loading** | Image URL broken or CORS issue | Verify URL format from API response |

## Gotchas & Best Practices

1. **SessionStorage Key Naming:** Use immutable string literals, not dynamic keys
   ```csharp
   // ✅ Good
   private const string KEY = "game_solitaire";
   
   // ❌ Bad
   var key = $"game_{GameType}";  // Different key per GameType = lost state
   ```

2. **Async Initialization:** Always await `OnInitializedAsync()` before accessing state
   ```csharp
   // ❌ Bad: Accessing uninitialized gameState
   protected override Task OnInitializedAsync() { // Missing await
       gameState = await sessionStorage.GetItemAsync(...);
   }
   
   // ✅ Good
   protected override async Task OnInitializedAsync() {
       gameState = await sessionStorage.GetItemAsync(...);
   }
   ```

3. **Card Identity:** Use `Card.Code` (unique) for move validation, not just rank/suit
   ```csharp
   // Two Aces of Spades can exist if shuffled from different decks
   // Use "AS" code, not just "ACE" + "SPADES"
   ```

4. **Cascading State Changes:** When moving a card, update all affected lists atomically
   ```csharp
   // ✅ Good: Atomic update
   gameState.Tableau[from].RemoveAt(index);
   gameState.Tableau[to].Add(card);
   
   // ❌ Bad: Partial update if exception between
   gameState.Tableau[from].RemoveAt(index);
   // ... exception here leaves game in inconsistent state
   gameState.Tableau[to].Add(card);
   ```

5. **API Resilience:** Never assume `deckofcardsapi.com` is always available
   ```csharp
   // Always have a fallback
   try {
       return await InitializeFromApiAsync();
   } catch (HttpRequestException) {
       return GenerateLocalDeck();
   }
   ```

## Architecture Decision Records (ADRs)

### ADR-001: External API for Card Shuffling

**Decision:** Use free `deckofcardsapi.com` for deck initialization
**Rationale:** Guaranteed randomness; reduces client-side implementation
**Trade-off:** Network dependency; API downtime blocks game start
**Status:** Active
**Future:** Consider local shuffle fallback

### ADR-002: SessionStorage for Game State

**Decision:** Persist game state in `Blazored.SessionStorage` (browser session)
**Rationale:** No server storage required; privacy-respecting; works offline
**Trade-off:** Cleared when browser closed; no game history between sessions
**Status:** Active
**Alternative:** Save to database for persistence across sessions

### ADR-003: Component-Driven Game Logic

**Decision:** Game logic (rules, validation) in dedicated components/utilities, not in Page files
**Rationale:** Testable; reusable for multiple game implementations
**Status:** In-progress
**Notes:** `CardComparer` utility demonstrates pattern; Black Jack logic should follow

## References

- Parent Architecture: [jsnover.net/.copilot-instructions](../../.copilot-instructions)
- Infrastructure & Services: [Infrastructure/.copilot-instructions](../Infrastructure/.copilot-instructions)
- Components (UI): [Components/.copilot-instructions](../Components/.copilot-instructions)
- Data Layer: [Data/.copilot-instructions](../Data/.copilot-instructions)
- Testing Strategy: [UnitTests/.copilot-instructions](../../UnitTests/.copilot-instructions)

---

**Last Updated:** February 2026 | **Pattern:** State Machine | **External API:** deckofcardsapi.com
