# Data Layer - Copilot Instructions

**Focus Area:** Database contexts, entity models, relationships, migrations, connection strings, EF Core configuration.

**Key Files:**
- Contexts: `Data/ApplicationDbContext.cs`, `Data/jsnoverdotnetdbContext.cs`
- Models: `Models/Blog.cs`, `Models/Card.cs`, `Models/Tag.cs`, `Models/Photos.cs`, `Models/Commentors.cs`, `Models/Subscribers.cs`, `Models/AspNetUsers.cs`, etc.
- Migrations: `Data/Migrations/` (auto-generated by EF Core)
- Configuration: `DataTransferObjects/Common/ContextOptions.cs`

## Database Architecture Overview

The solution uses **two separate DbContexts**:

```
ApplicationDbContext (Identity)
    ├── AspNetUsers
    ├── AspNetRoles
    ├── AspNetUserClaims
    ├── AspNetUserLogins
    ├── AspNetUserRoles
    └── AspNetUserTokens

jsnoverdotnetdbContext (Business Domain)
    ├── Blog
    │   ├── → Tags (1:M via BlogId FK)
    │   ├── → Commentors (1:M via BlogId FK)
    │   └── → Photos (M:M or array-based)
    ├── Subscribers
    ├── Card
    ├── CardDraw
    ├── NewDeck
    ├── ContactRequest
    ├── VisitorCounter
    └── Owners (admin metadata)
```

### Two DbContexts: Why?

**Reason:** Scaffolded from existing SQL Server database; high refactoring cost to consolidate

**Pros:**
- Separation of concerns (Identity vs. Business)
- No cross-context dependencies
- Easier to migrate separately

**Cons:**
- ❌ No transactions across contexts
- ❌ Duplicate connection management
- ❌ Confusing to new developers

**Recommendation:** Keep separate for now; consider consolidation in major refactor

## Connection String Management

**Location:** Multiple places (anti-pattern ⚠️)

### Current Approach

**appsettings.json:**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=.;Database=jsnoverdotnet;Integrated Security=True"
  }
}
```

**Startup.cs:**
```csharp
public void ConfigureServices(IServiceCollection services) {
    services.AddDbContext<ApplicationDbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
    
    services.AddDbContext<jsnoverdotnetdbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
}
```

**ContextOptions.cs (redundant):**
```csharp
public static class ContextOptions {
    public static string ConnectionString { get; set; }
    // Should come from IConfiguration, not static
}
```

### Best Practice (Not Currently Implemented)

```csharp
// In Startup.cs
services.Configure<DatabaseOptions>(Configuration.GetSection("Database"));

// In dependency-injected services
public class BlogService {
    private readonly IOptions<DatabaseOptions> _dbOptions;
    
    public BlogService(IOptions<DatabaseOptions> dbOptions) {
        _dbOptions = dbOptions.Value;
    }
}
```

## Entity Models

### Blog Entity

**Location:** `Models/Blog.cs`

```csharp
public class Blog {
    [Key]
    public int BlogId { get; set; }                    // Primary Key
    
    public string BlogTitle { get; set; }              // Article title
    public string BlogAuthor { get; set; }             // Author name
    public string BlogContent { get; set; }            // HTML content
    public string BlogType { get; set; }               // Category (e.g., "Technical", "Personal")
    
    [DatabaseGenerated(DatabaseGeneratedOption.Computed)]
    public DateTime DatePublished { get; set; }        // Auto-filled on creation
    public DateTime? DateModified { get; set; }        // Updated when blog edited
    
    // Navigation Properties
    public virtual ICollection<Tag> Tags { get; set; } = new List<Tag>();
    public virtual ICollection<Commentors> Comments { get; set; } = new List<Commentors>();
    public virtual ICollection<Photos> AssociatedPhotos { get; set; } = new List<Photos>();
}
```

**Relationships:**
- Blog → Tags (1:Many) via `BlogId` foreign key
- Blog → Commentors (1:Many) via `BlogId` foreign key
- Blog → Photos (1:Many or array-based reference)

---

### Tag Entity

```csharp
public class Tag {
    [Key]
    public int TagId { get; set; }
    
    public int? BlogId { get; set; }           // Foreign Key to Blog
    public string TagName { get; set; }        // e.g., "Blazor", "CSharp"
    
    // Navigation Property
    [ForeignKey("BlogId")]
    public virtual Blog Blog { get; set; }
}
```

**Gotcha:** `BlogId` nullable; allows orphaned tags. Could enforce FK delete cascade.

---

### Commentors Entity (Comments)

```csharp
public class Commentors {
    [Key]
    public int CommentId { get; set; }
    
    public int BlogId { get; set; }            // Foreign Key to Blog
    public string CommentorName { get; set; }
    public string CommentorEmail { get; set; }
    public string CommentText { get; set; }
    public DateTime DateCommented { get; set; }
    
    [ForeignKey("BlogId")]
    public virtual Blog Blog { get; set; }
}
```

**Naming Issue ⚠️:** Class name `Commentors` (plural) suggests collection; should be `Comment` (singular)

**Best Practice:** Use `Comment` as entity name, `Comments` for collection
```csharp
public class Comment {
    // ... same properties
}

public virtual ICollection<Comment> Comments { get; set; }
```

---

### Photos Entity

```csharp
public class Photos {
    [Key]
    public int PhotoId { get; set; }
    
    public string PhotoName { get; set; }      // Unique identifier
    [MaxLength(int.MaxValue)]
    public byte[] PhotoImage { get; set; }     // Binary image data
    public string ContentType { get; set; }    // e.g., "image/jpeg"
    
    public int? BlogId { get; set; }           // Foreign Key (optional)
}
```

**Note:** Photos stored as binary in database; consider migration to blob storage (Azure Blob, AWS S3) for production

---

### Card Entity (Games)

```csharp
public class Card {
    [Key]
    public int CardId { get; set; }
    
    public string Code { get; set; }           // 2-char code: "AS" (Ace of Spades)
    public string Suit { get; set; }           // SPADES, HEARTS, DIAMONDS, CLUBS
    public string Rank { get; set; }           // ACE, 2-10, JACK, QUEEN, KING
    public string Value { get; set; }          // Numeric value for calculation
    public string ImageUrl { get; set; }       // URL from deckofcardsapi.com
}
```

---

### Subscribers Entity

```csharp
public class Subscribers {
    [Key]
    public int SubscriberId { get; set; }
    
    public string Email { get; set; }          // Must be unique
    public DateTime DateSubscribed { get; set; }
    public bool IsActive { get; set; }         // Allow unsubscribe
}
```

**Best Practice:** Add unique constraint
```csharp
[Index(nameof(Email), IsUnique = true)]
public class Subscribers {
    // ...
}
```

---

### ContactRequest Entity

```csharp
public class ContactRequest {
    [Key]
    public int ContactId { get; set; }
    
    public string Name { get; set; }
    public string Email { get; set; }
    public string Message { get; set; }
    public DateTime DateSubmitted { get; set; }
    public bool? IsResolved { get; set; }
}
```

---

### VisitorCounter Entity

```csharp
public class VisitorCounter {
    [Key]
    public int CounterId { get; set; }
    
    public int TotalVisits { get; set; }
    public DateTime LastVisitTime { get; set; }
    public DateTime FirstVisitTime { get; set; }
}
```

---

### AspNetUsers, AspNetRoles, etc. (Identity)

Scaffolded by Identity framework; auto-generated. See [Auth & Identity Instructions]().

## DbContext Classes

### jsnoverdotnetdbContext (Business Domain)

**Location:** `Data/jsnoverdotnetdbContext.cs`

```csharp
public class jsnoverdotnetdbContext : DbContext {
    public jsnoverdotnetdbContext() { }
    
    public jsnoverdotnetdbContext(DbContextOptions<jsnoverdotnetdbContext> options)
        : base(options) { }
    
    // Entity Sets
    public virtual DbSet<Blog> Blogs { get; set; }
    public virtual DbSet<Tag> Tags { get; set; }
    public virtual DbSet<Commentors> Commentors { get; set; }
    public virtual DbSet<Photos> Photos { get; set; }
    public virtual DbSet<Subscribers> Subscribers { get; set; }
    public virtual DbSet<Card> Cards { get; set; }
    public virtual DbSet<CardDraw> CardDraws { get; set; }
    public virtual DbSet<NewDeck> NewDecks { get; set; }
    public virtual DbSet<ContactRequest> ContactRequests { get; set; }
    public virtual DbSet<VisitorCounter> VisitorCounters { get; set; }
    
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) {
        if (!optionsBuilder.IsConfigured) {
            optionsBuilder.UseSqlServer(ContextOptions.ConnectionString);
        }
    }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder) {
        // Relationships
        modelBuilder.Entity<Tag>()
            .HasOne(t => t.Blog)
            .WithMany(b => b.Tags)
            .HasForeignKey(t => t.BlogId)
            .OnDelete(DeleteBehavior.Cascade);
        
        modelBuilder.Entity<Commentors>()
            .HasOne(c => c.Blog)
            .WithMany(b => b.Comments)
            .HasForeignKey(c => c.BlogId)
            .OnDelete(DeleteBehavior.Cascade);
        
        // Indices
        modelBuilder.Entity<Subscribers>()
            .HasIndex(s => s.Email)
            .IsUnique();
        
        // Value conversions (if needed)
        modelBuilder.Entity<Blog>()
            .Property(b => b.DatePublished)
            .HasDefaultValueSql("GETUTCDATE()");
    }
}
```

### ApplicationDbContext (Identity)

**Location:** `Data/ApplicationDbContext.cs`

```csharp
public class ApplicationDbContext : IdentityDbContext<IdentityUser> {
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options) { }
    
    // Identity DbSet's auto-included by IdentityDbContext
    // No need to add: IdentityUsers, IdentityRoles, etc.
}
```

**Note:** Inherits from `IdentityDbContext<IdentityUser>`, which provides Identity tables

## Migrations

**Location:** `Data/Migrations/`

### How Migrations Work

1. **Create:** Edit entity model in `/Models/`
2. **Generate:** `dotnet ef migrations add MigrationName -OutputDir Data/Migrations`
3. **Review:** Check generated migration file for correctness
4. **Apply:** `dotnet ef database update` or via Azure DevOps pipeline

### Existing Migrations

Migrations are auto-generated from database schema. Each covers:
- Table creation
- Foreign keys
- Indices
- Defaults

### Common Migration Tasks

**Add a Column to Blog:**
```csharp
// Step 1: Edit Blog.cs
public class Blog {
    // ... existing properties
    public string ImageUrl { get; set; }  // NEW
}

// Step 2: Generate migration
// PowerShell: Add-Migration AddBlogImageUrl -OutputDir Data/Migrations
// CLI: dotnet ef migrations add AddBlogImageUrl -OutputDir Data/Migrations

// Step 3: Generated migration file looks like:
protected override void Up(MigrationBuilder migrationBuilder) {
    migrationBuilder.AddColumn<string>(
        name: "ImageUrl",
        table: "Blogs",
        nullable: true);
}

// Step 4: Apply
// PowerShell: Update-Database
// CLI: dotnet ef database update
```

### Migration Best Practices

1. **Meaningful names:** `AddBlogImageUrl` > `Migration1`
2. **One change per migration:** Easier to revert
3. **Reversible:** Down() method should undo Up()
4. **No breaking changes:** Add column as nullable, then migrate data, then NOT NULL
5. **Seed data separately:** Use separate migration or seed method
6. **Version control:** Commit migration files to git

## Relationships & Navigation Properties

### One-to-Many (Blog → Tags)

```csharp
public class Blog {
    public int BlogId { get; set; }
    public virtual ICollection<Tag> Tags { get; set; } = new List<Tag>();
}

public class Tag {
    public int TagId { get; set; }
    public int? BlogId { get; set; }
    [ForeignKey("BlogId")]
    public virtual Blog Blog { get; set; }
}

// Usage:
var blog = await context.Blogs.Include(b => b.Tags).FirstOrDefaultAsync(b => b.BlogId == 1);
var blogTags = blog.Tags;  // Automatically loaded
```

### Many-to-Many (Blog ↔ Subscribers via Comments)

**Current Implementation:** Not directly M:M; instead array-based or separate Comment table

**True M:M Pattern (if needed):**
```csharp
// Join table
public class BlogSubscriber {
    public int BlogId { get; set; }
    public int SubscriberId { get; set; }
    
    [ForeignKey("BlogId")]
    public virtual Blog Blog { get; set; }
    
    [ForeignKey("SubscriberId")]
    public virtual Subscriber Subscriber { get; set; }
}

// In OnModelCreating
modelBuilder.Entity<BlogSubscriber>()
    .HasKey(bs => new { bs.BlogId, bs.SubscriberId });
```

## Query Patterns

### Basic Select

```csharp
// Single entity
var blog = await context.Blogs.FirstOrDefaultAsync(b => b.BlogId == 5);

// Multiple entities
var blogs = await context.Blogs.ToListAsync();

// With filter
var technicalBlogs = await context.Blogs
    .Where(b => b.BlogType == "Technical")
    .ToListAsync();
```

### Eager Loading (Include)

```csharp
// Load blog with related tags and comments
var blog = await context.Blogs
    .Include(b => b.Tags)
    .Include(b => b.Comments)
    .FirstOrDefaultAsync(b => b.BlogId == 5);

// Now accessing blog.Tags doesn't trigger another query
var tagNames = blog.Tags.Select(t => t.TagName).ToList();
```

### Lazy Loading (Explicit)

```csharp
var blog = await context.Blogs.FirstOrDefaultAsync(b => b.BlogId == 5);

// Load tags separately (another query)
var tags = await context.Tags
    .Where(t => t.BlogId == blog.BlogId)
    .ToListAsync();
```

### Projection (Select)

```csharp
// Load only specific columns (more efficient)
var blogSummaries = await context.Blogs
    .Select(b => new {
        b.BlogId,
        b.BlogTitle,
        b.DatePublished
    })
    .ToListAsync();  // Returns anonymous objects, not full Blog entities
```

### Pagination

```csharp
int pageSize = 10;
int pageNumber = 2;  // 2nd page

var pagedBlogs = await context.Blogs
    .OrderByDescending(b => b.DatePublished)
    .Skip((pageNumber - 1) * pageSize)
    .Take(pageSize)
    .ToListAsync();
```

### Aggregation

```csharp
// Count
var blogCount = await context.Blogs.CountAsync();

// Average
var avgCommentsPerBlog = await context.Commentors
    .GroupBy(c => c.BlogId)
    .Select(g => g.Count())
    .AverageAsync();

// Distinct
var authors = await context.Blogs
    .Select(b => b.BlogAuthor)
    .Distinct()
    .ToListAsync();
```

## Change Tracking & SaveChanges

### Entity States

```csharp
var blog = new Blog { BlogTitle = "New" };
context.Blogs.Add(blog);
// State: Added

await context.SaveChangesAsync();
// State: Unchanged (persisted)

blog.BlogTitle = "Updated";
// State: Modified (change tracked automatically)

await context.SaveChangesAsync();
// State: Unchanged

context.Blogs.Remove(blog);
// State: Deleted

await context.SaveChangesAsync();
// State: Detached (no longer tracked)
```

### Disable Change Tracking (For Read-Only)

```csharp
var blogs = await context.Blogs
    .AsNoTracking()  // Don't track for updates
    .ToListAsync();

// Memory efficient for large datasets
// ~30% faster, ~30% less memory
```

### Manual SaveChanges

```csharp
context.ChangeTracker.DetectChanges();  // Detect changes manually
await context.SaveChangesAsync();
```

## Concurrency Handling

### Optimistic Concurrency (Row Version)

```csharp
public class Blog {
    [Timestamp]
    public byte[] RowVersion { get; set; }  // Auto-managed by EF Core
}

// In OnModelCreating:
modelBuilder.Entity<Blog>()
    .Property(b => b.RowVersion)
    .IsRowVersion();

// Usage:
try {
    await context.SaveChangesAsync();
} catch (DbUpdateConcurrencyException ex) {
    // Another user modified the same blog
    // Display message or merge changes
}
```

## Performance Best Practices

### 1. Use .AsNoTracking() for Read-Only

```csharp
// ✅ Efficient: No change tracking overhead
var blogs = await context.Blogs.AsNoTracking().ToListAsync();

// ❌ Inefficient: Unnecessary change tracking
var blogs = await context.Blogs.ToListAsync();
```

### 2. Eager Load Related Data

```csharp
// ✅ Efficient: Single query with JOIN
var blog = await context.Blogs
    .Include(b => b.Tags)
    .FirstOrDefaultAsync(b => b.BlogId == 5);

// ❌ Inefficient: N+1 queries (load blog, then all tags)
var blog = await context.Blogs.FirstOrDefaultAsync(b => b.BlogId == 5);
foreach (var tag in context.Tags.Where(t => t.BlogId == blog.BlogId)) { }
```

### 3. Use Pagination for Large Datasets

```csharp
// ✅ Efficient: Limited result set
var blogs = await context.Blogs
    .Skip(0).Take(20)
    .ToListAsync();

// ❌ Inefficient: Load all blogs (memory spike)
var blogs = await context.Blogs.ToListAsync();
var first20 = blogs.Take(20).ToList();
```

### 4. Project Before ToList()

```csharp
// ✅ Efficient: Project in database, return 3 fields
var titles = await context.Blogs
    .Select(b => b.BlogTitle)
    .ToListAsync();

// ❌ Inefficient: Load entire entity, filter in memory
var blogs = await context.Blogs.ToListAsync();
var titles = blogs.Select(b => b.BlogTitle).ToList();
```

## Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| **DbContext disposed error** | Using context after disposal | Don't access properties after SaveChangesAsync returns |
| **Lazy loading doesn't work** | Navigation property not loaded | Use `.Include()` or `.AsNoTracking().Include()` |
| **SaveChanges fails silently** | No exception thrown | Check return value; ensure SaveChangesAsync awaited |
| **Orphaned records after delete** | No cascade delete configured | Add `OnDelete(DeleteBehavior.Cascade)` in OnModelCreating |
| **Unique constraint violation** | Duplicate value in unique column | Check `[Index(IsUnique = true)]` configuration |
| **Migration conflicts** | Multiple migrations with same name | Delete conflicting migration, regenerate |
| **Query timeout** | No indices on filtered columns | Add `[Index]` to frequently filtered properties |

## Key Gotchas

1. **Null Navigation Properties:** Unless `.Include()` used, navigation properties are null
2. **Timestamp Columns:** `RowVersion` auto-managed; don't set manually
3. **Default Values:** Configured in `OnModelCreating`, not in C# property initializers
4. **Cascading Deletes:** Default is NO ACTION; configure in relationship
5. **SaveChanges Returns Count:** `int` = number of rows affected
6. **Async/Await Required:** Always use `.ToListAsync()`, not `.ToList()` in async method

## References

- Parent Architecture: [jsnover.net/.copilot-instructions](../../.copilot-instructions)
- Infrastructure (Repository): [Infrastructure/.copilot-instructions](../Infrastructure/.copilot-instructions)
- Blog Models/Relationships: [.copilot-instructions](../.copilot-instructions)
- Games Models: [GameLogic/.copilot-instructions](../GameLogic/.copilot-instructions)

---

**Last Updated:** February 2026 | **Pattern:** EF Core Code-First | **Database:** SQL Server | **Two DbContexts:** Identity + Business
